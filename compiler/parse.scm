(define (make-arginfo name)
  (list name	;; name
	#f	;; arg is ever captured
	#f))	;; arg is ever mutated

(define (arginfo-name ai)		(car ai))
(define (arginfo-captured? ai)		(cadr ai))
(define (arginfo-mutated? ai)		(caddr ai))

(define (arginfo-capture! ai)		(set-car! (cdr ai) #t))
(define (arginfo-mutate! ai)		(set-car! (cddr ai) #t))

(define (parse-body scope body)
  (let collect-definitions ((defs '()) (exprs (flatten-body body)))
    (if (and (not (null? exprs))
	     (list? (car exprs))
	     (eq? (caar exprs) 'define))
	(if (pair? (cadar exprs))
	    (let* ((definition (cdar exprs))
		   (template (car definition))
		   (body (cdr definition))
		   (varname (car template))
		   (arglist (cdr template)))
	      (collect-definitions (append defs (list `(,varname (lambda ,arglist ,@body))))
				   (cdr exprs)))
	    (collect-definitions (append defs (list (cdar exprs))) (cdr exprs)))
	(if (null? defs)
	    (parse scope (cons 'begin exprs))
	    (let ((temps (map (lambda (binding) (list (gensym (symbol->string (car binding)))
						      (car binding)))
			      defs)))
	      (parse scope
		     `((lambda ,(map car defs)
			 ((lambda ,(map car temps)
			    ,@(map (lambda (xbinding) `(set! ,(cadr xbinding) ,(car xbinding)))
				   temps)
			    ,@exprs)
			  ,@(map cadr defs)))
		       ,@(map (lambda (x) #f) defs))))))))

(define (parse-combination scope expr)
  (make-apply (parse scope (car expr))
	      (map (lambda (x) (parse scope x)) (cdr expr))))

(define (variable-global-in-scope? var scope)
  (not (any (lambda (x) (memq var x)) scope)))

(define (remove-quote x)
  (if (not (and (pair? x)
		(eq? (car x) 'quote)))
      (error "#%extern-apply missing required quoting:" x)
      (cadr x)))

(define (parse scope expr)
  (cond
   ((symbol? expr)
    (make-var expr (variable-global-in-scope? expr scope)))
   ((not (pair? expr))
    (make-lit expr))
   ((not (and (symbol? (car expr))
	      (variable-global-in-scope? (car expr) scope)))
    (parse-combination scope expr))
   (else
    (case (car expr)
      ((quote)
       (make-lit (cadr expr)))
      ((define)
       (error "syntax-error"
	      "Internal definition invalid unless at the start of a body:"
	      (and (not (null? (cdr expr)))
		   (cadr expr))))
      ((lambda)
       (letrec ((orig-args (cadr expr))
		(orig-body (cddr expr))
		(listify (lambda (args)
			   (if (pair? args)
			       (cons (car args) (listify (cdr args)))
			       (list args)))))
	 (let* ((new-args (if (list? orig-args)
			      orig-args
			      (listify orig-args)))
		(new-node (make-lambda (map make-arginfo new-args)
				       (parse-body (cons new-args scope)
						   orig-body))))
	   (syntax-assert lambda-requires-formals-to-be-symbols
			  (every symbol? new-args))
	   (if (not (list? orig-args))
	       (node-set! new-node 'lambda 'varargs #t))
	   new-node)))
      ((begin)
       (let ((exprs (flatten-body (cdr expr))))
	 (cond 
	  ((null? exprs) (make-singleton 'undefined))
	  ((null? (cdr exprs)) (parse scope (car exprs)))
	  (else
	   (make-begin (parse scope (car exprs))
		       (parse scope (cons 'begin (cdr exprs))))))))
      ((if)
       (if (null? (cdddr expr))
	   (make-if (parse scope (cadr expr))
		    (parse scope (caddr expr))
		    (make-singleton 'undefined))
	   (make-if (parse scope (cadr expr))
		    (parse scope (caddr expr))
		    (parse scope (cadddr expr)))))
      ((set!)
       (make-set (cadr expr)
		 (parse scope (caddr expr))))
      ((#%extern-apply)
       (make-extern-apply (remove-quote (cadr expr))
			  (remove-quote (caddr expr))
			  (map (lambda (x) (parse scope x)) (cdddr expr))))
      (else
       (parse-combination scope expr))))))
