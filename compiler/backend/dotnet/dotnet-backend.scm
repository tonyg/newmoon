(define dotnet-languages
  `(
    (id ,string?)
    (type ,string?)

    (classdef (classdef (name id)
			(extends type)
			(fields (%list-of fielddef))
			(methods (%list-of methdef))))

    (fielddef (fielddef (name id)
			(type type)))

    (argdef (argdef (name id)
		    (type type)))

    (methdef (methdef (name id)
		      (virtual ,boolean?)
		      (static ,boolean?)
		      (rettype type)
		      (formals (%list-of argdef))
		      (body (%list-of instr))))

    (instr #t)
    ))

(define *max-non-varargs-arity* 4)

(define *il-closure-type* "class [Newmoon]Newmoon.Closure")
(define *il-module-type* "class [Newmoon]Newmoon.Module")
(define *il-objarray-type* "object[]")

(define (make-counter receiver)
  (let ((counter 0))
    (lambda ()
      (let ((c counter))
	(set! counter (+ counter 1))
	(receiver c)))))

(define (mangle-id sym-or-str)
  (let ((str (if (symbol? sym-or-str) (symbol->string sym-or-str) sym-or-str)))
    (list->string
     (cons* #\N #\_
	    (fold-right (lambda (char acc)
			  (if (or (char-alphabetic? char)
				  (char-numeric? char))
			      (cons char acc)
			      (case char
				((#\-) (cons* #\_ #\_ acc))
				(else (cons* #\_ #\x (append (string->list
							      (number->string
							       (char->integer char) 16))
							     (cons #\_ acc)))))))
			'()
			(string->list str))))))

(define (make-classdef name extends)
  (make-node 'classdef
	     'name name
	     'extends extends
	     'fields '()
	     'methods '()))

(define (classdef-add-method! classdef name virtual static rettype formals)
  (let ((methdef (make-node 'methdef
			    'name name
			    'virtual virtual
			    'static static
			    'rettype rettype
			    'formals (map (lambda (entry)
					    (make-node 'argdef
						       'name (car entry)
						       'type (cadr entry)))
					  formals)
			    'body '())))
    (node-push! classdef 'classdef 'methods methdef)
    methdef))

(define (add-instr! methdef instr)
  (node-push! methdef 'methdef 'body instr))

(define (add-instrs! methdef instrs)
  (for-each (lambda (i) (add-instr! methdef i)) instrs))

(define (emit port . items)
  (emit* port items))

(define (emit* port items)
  (for-each (lambda (item) (display item port)) items))

(define (il-file-prologue port assemblyname)
  (emit port
	"// Generated by Newmoon\n"
	".assembly '"assemblyname"' {}\n"
	".assembly extern mscorlib {}\n"
	".assembly extern Newmoon {}\n"
	"\n"))

(define (emit-classdef port)
  (lambda (classdef)
    (emit port
	  ".class public auto ansi beforefieldinit "(node-get classdef 'classdef 'name)"\n"
	  #\tab"extends "(node-get classdef 'classdef 'extends)"\n"
	  "{\n")
    (for-each (emit-fielddef port) (node-get classdef 'classdef 'fields))
    (for-each (emit-methdef port) (node-get classdef 'classdef 'methods))
    (emit port
	  "}\n\n")))

(define (emit-fielddef port)
  (lambda (fielddef)
    (emit port
	  #\tab".field public "(node-get fielddef 'fielddef 'type)" "
	  (node-get fielddef 'fielddef 'name)"\n")))

(define (emit-methdef port)
  (lambda (methdef)
    (emit port "\n")
    (if (node-get methdef 'methdef 'static)
	(emit port #\tab".method public static hidebysig default\n")
	(begin
	  (emit port #\tab".method public")
	  (if (node-get methdef 'methdef 'virtual) (emit port " virtual newslot"))
	  (emit port " hidebysig instance default\n")))
    (emit port
	  #\tab (node-get methdef 'methdef 'rettype)
	  " "(node-get methdef 'methdef 'name))
    (emit-formals port (node-get methdef 'methdef 'formals))
    (emit port "\n"#\tab"cil managed\n"#\tab"{\n")
    (emit-instructions port (node-get methdef 'methdef 'body))
    (emit port #\tab"}\n")))

(define (emit-formals port formals)
  (emit port "(")
  (let loop ((formals formals)
	     (need-comma #f))
    (if (null? formals)
	(emit port ")")
	(let* ((formal (car formals))
	       (type (node-get formal 'argdef 'type))
	       (name (node-get formal 'argdef 'name)))
	  (if need-comma (emit port ", "))
	  (emit port type" "name)
	  (loop (cdr formals) #t)))))

(define (emit-instructions port instrs)
  (for-each (lambda (instr)
	      (emit port #\tab)
	      (if (or (symbol? instr) (string? instr))
		  (emit port instr":")
		  (for-each (lambda (part) (emit port #\tab part)) instr))
	      (emit port "\n"))
	    (reverse instrs)))

(define (compiler-back-end-phases input-filename frontend-result)
  (let* ((next-lambda-name (make-counter (lambda (c) (string-append "Lambda_" (number->string c)))))
	 (next-label (make-counter (lambda (c) (string-append "L" (number->string c)))))
	 (assembly-name (replace-filename-extension input-filename ""))
	 (fq-namespace (string-append "Newmoon.CompiledModules."(mangle-id assembly-name)))
	 (output-filename (replace-filename-extension input-filename ".il"))
	 (statics-classdef (make-classdef "Statics" "[mscorlib]System.Object"))
	 (statics-classname (string-append "class "fq-namespace".Statics"))
	 (literal-table (make-hash-table 'equal))
	 (global-table (make-hash-table))
	 (all-classdefs (list statics-classdef)))

    (define (qualify id)
      (string-append fq-namespace"."id))

    (define (qualify-class id)
      (string-append "class "fq-namespace"."id))

    (define (record-generated-class! classdef)
      (set! all-classdefs (cons classdef all-classdefs)))

    (define (gen-closure parenttype node)
      (let* ((formals (node-get node 'cps-lambda 'formals))
	     (captures (node-get node 'cps-lambda 'captures))
	     (num-captures (length captures))
	     (varargs (node-get node 'cps-lambda 'varargs))
	     (globals (node-get node 'cps-lambda 'globals))
	     (expr (node-get node 'cps-lambda 'expr))
	     (arity (let ((fl (length formals))) (if varargs (- fl 1) fl)))
	     (supertype "[Newmoon]Newmoon.Closure")
	     (lambdaname (next-lambda-name))
	     (lambdatype (qualify-class lambdaname))
	     (classdef (make-classdef lambdaname supertype)))

	(define (gen-fixed-low-arity)
	  (let ((applyv (classdef-add-method! classdef "ApplyVarargs" #t #f "object"
					      `((k ,*il-closure-type*)
						(args ,*il-objarray-type*)))))
	    ;;(add-instrs! 
	    'dummy))

	(define (gen-fixed-high-arity)
	  (let ((applyv (classdef-add-method! classdef "ApplyVarargs" #t #f "object"
					      `((k ,*il-closure-type*)
						(args ,*il-objarray-type*)))))
	    ;;(add-instrs! 
	    'dummy))

	(define (gen-variable-arity)
	  (let ((applyv (classdef-add-method! classdef "ApplyVarargs" #t #f "object"
					      `((k ,*il-closure-type*)
						(args ,*il-objarray-type*)))))
	    ;;(add-instrs! 
	    'dummy))

	(compiler-assert root-lambda-no-captures (or parenttype
						     (zero? num-captures)))

	(let ((ctor (classdef-add-method! classdef ".ctor" #f #f "void"
					  (if parenttype
					      `((module ,*il-module-type*)
						(oldenv ,parenttype))
					      `((module ,*il-module-type*))))))
	  (add-instrs! ctor `((ldarg.0)
			      (call "instance void object::.ctor()")))
	  (add-instr! ctor '("// compute captures %%%%%%"))
	  (add-instr! ctor '(ret)))

	(if (and (<= arity *max-non-varargs-arity*) (not varargs))
	    (gen-fixed-low-arity)
	    (if varargs
		(gen-variable-arity)
		(gen-fixed-high-arity)))

	(record-generated-class! classdef)
	lambdatype))

    ;;---------------------------------------------------------------------------
    (for-each display (list ";; dotnet backend compiling to namespace "fq-namespace"\n"))
    (gen-closure #f frontend-result)

    (for-each display (list ";; dotnet backend generating "output-filename"\n"))
    (delete-file-if-exists output-filename)
    (call-with-output-file output-filename
      (lambda (o)
	(il-file-prologue o (mangle-id assembly-name))
	(emit o ".namespace "fq-namespace"\n{\n\n")
	(for-each (emit-classdef o) all-classdefs)
	(emit o "\n} // namespace "fq-namespace"\n")))))
