(define dotnet-languages
  `(
    (id ,string?)
    (type ,string?)

    (classdef (classdef (name id)
			(extends type)
			(fields (%list-of fielddef))
			(methods (%list-of methdef))))

    (fielddef (fielddef (name id)
			(type type)))

    (argdef (argdef (name id)
		    (type type)))

    (methdef (methdef (name id)
		      (virtual ,boolean?)
		      (static ,boolean?)
		      (rettype type)
		      (formals (%list-of argdef))
		      (body (%list-of instr))))

    (instr #t)
    ))

(define (make-counter receiver)
  (let ((counter 0))
    (lambda ()
      (let ((c counter))
	(set! counter (+ counter 1))
	(receiver c)))))

(define (mangle-id sym-or-str)
  (let ((str (if (symbol? sym-or-str) (symbol->string sym-or-str) sym-or-str)))
    (list->string
     (cons* #\N #\_
	    (fold-right (lambda (char acc)
			  (if (or (char-alphabetic? char)
				  (char-numeric? char))
			      (cons char acc)
			      (case char
				((#\-) (cons* #\_ #\_ acc))
				(else (cons* #\_ #\x (append (string->list
							      (number->string
							       (char->integer char) 16))
							     (cons #\_ acc)))))))
			'()
			(string->list str))))))

(define (make-classdef name extends)
  (make-node 'classdef
	     'name name
	     'extends extends
	     'fields '()
	     'methods '()))

(define (classdef-add-method! classdef name virtual static rettype formals)
  (let ((methdef (make-node 'methdef
			    'name name
			    'virtual virtual
			    'static static
			    'rettype rettype
			    'formals (map (lambda (entry)
					    (make-node 'argdef
						       'name (car entry)
						       'type (cadr entry)))
					  formals)
			    'body '())))
    (node-push! classdef 'classdef 'methods methdef)
    methdef))

(define (emit port . items)
  (emit* port items))

(define (emit* port items)
  (for-each (lambda (item) (display item port)) items))

(define (il-file-prologue port)
  (emit port
	"// Generated by Newmoon" #\newline
	#\newline))

(define (emit-classdef port)
  (lambda (classdef)
    (emit port
	  ".class public auto ansi beforefieldinit "(node-get classdef 'classdef 'name)"\n"
	  #\tab"extends "(node-get classdef 'classdef 'extends)"\n"
	  "{\n")
    (for-each (emit-fielddef port) (node-get classdef 'classdef 'fields))
    (for-each (emit-methdef port) (node-get classdef 'classdef 'methods))
    (emit port
	  "}\n\n")))

(define (emit-fielddef port)
  (lambda (fielddef)
    (emit port
	  #\tab".field public "(node-get fielddef 'fielddef 'type)" "
	  (node-get fielddef 'fielddef 'name)"\n")))

(define (emit-methdef port)
  (lambda (methdef)
    (emit port "\n")
    (if (node-get methdef 'methdef 'static)
	(emit port #\tab".method public static hidebysig\n")
	(begin
	  (emit port #\tab".method public hidebysig specialname rtspecialname instance")
	  (if (node-get methdef 'methdef 'virtual) (emit port " virtual"))
	  (emit port "\n")))
    (emit port
	  #\tab (node-get methdef 'methdef 'rettype)
	  " "(node-get methdef 'methdef 'name))
    (emit-formals port (node-get methdef 'methdef 'formals))
    (emit port "\n"#\tab"cil managed\n"#\tab"{\n")
    (emit-instructions port (node-get methdef 'methdef 'body))
    (emit port #\tab"}\n")))

(define (emit-formals port formals)
  (emit port "(")
  (let loop ((formals formals)
	     (need-comma #f))
    (if (null? formals)
	(emit port ")")
	(let* ((formal (car formals))
	       (type (node-get formal 'argdef 'type))
	       (name (node-get formal 'argdef 'name)))
	  (if need-comma (emit port ", "))
	  (emit port type" "name)
	  (loop (cdr formals) #t)))))

(define (emit-instructions port instrs)
  (for-each (lambda (instr)
	      (emit port #\tab #\tab instr"\n"))
	    instrs))

(define (compiler-back-end-phases input-filename frontend-result)
  (let* ((next-lambda-name (make-counter (lambda (c) (string-append "Lambda_" (number->string c)))))
	 (assembly-name (mangle-id (replace-filename-extension input-filename "")))
	 (fq-namespace (string-append "Newmoon.CompiledModules."assembly-name))
	 (output-filename (replace-filename-extension input-filename ".il"))
	 (statics-classdef (make-classdef "Statics" "object"))
	 (statics-classname (string-append "class "fq-namespace".Statics"))
	 (literal-table (make-hash-table 'equal))
	 (all-classdefs (list statics-classdef)))

    (define (qualify id)
      (string-append fq-namespace"."id))

    (define (qualify-class id)
      (string-append "class "fq-namespace"."id))

    (define (record-generated-class! classdef)
      (set! all-classdefs (cons classdef all-classdefs)))

    (define (gen-closure parenttype node)
      (let* ((formals (node-get node 'cps-lambda 'formals))
	     (captures (node-get node 'cps-lambda 'captures))
	     (num-captures (length captures))
	     (varargs (node-get node 'cps-lambda 'varargs))
	     (globals (node-get node 'cps-lambda 'globals))
	     (expr (node-get node 'cps-lambda 'expr))
	     (arity (let ((fl (length formals))) (if varargs (- fl 1) fl)))
	     (supertype "class [Newmoon]Newmoon.Closure")
	     (lambdaname (next-lambda-name))
	     (lambdatype (qualify-class lambdaname))
	     (classdef (make-classdef lambdaname supertype)))

	(compiler-assert root-lambda-no-captures (or parenttype
						     (zero? num-captures)))

	(let ((ctor (classdef-add-method! classdef ".ctor" #f #f "void"
					  '())))
	  

	(record-generated-class! classdef)
	lambdatype))

    ;;---------------------------------------------------------------------------
    (for-each display (list ";; dotnet backend compiling to namespace "fq-namespace"\n"))
    (gen-closure #f frontend-result)

    (for-each display (list ";; dotnet backend generating "output-filename"\n"))
    (delete-file-if-exists output-filename)
    (call-with-output-file output-filename
      (lambda (o)
	(il-file-prologue o)
	(emit o ".namespace "fq-namespace"\n{\n\n")
	(for-each (emit-classdef o) all-classdefs)
	(emit o "\n} // namespace "fq-namespace"\n")))))
